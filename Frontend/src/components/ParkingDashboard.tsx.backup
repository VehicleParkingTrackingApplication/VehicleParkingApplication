import { useState, useEffect, useMemo } from 'react';
import { useSearchParams } from 'react-router-dom';
import { BarChart, Bar, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer, LineChart, Line, CartesianGrid } from 'recharts';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { authInterceptor } from '../services/authInterceptor';
import { getAllParkingAreas, getAllRecords, getExistingVehicles, getVehicleEntryPredictions } from '@/services/parking';
import { webSocketService } from '@/services/websocket';


// --- INTERFACES ---
interface VehicleRecord {
  _id: string;
  plateNumber: string;
  datetime: string;
  areaId: string;
}

// Represents the raw record data from the backend API
interface RawRecord {
  _id: string;
  plate: string;
  action: 'ENTRY' | 'EXIT';
  time: string;
  date: string;
  image: string;
  country: string;
  angle: number;
  confidence: number;
}

// Represents the enriched record object after client-side processing
interface ProcessedRecord {
  _id: string;
  plate: string;
  action: 'ENTRY' | 'EXIT';
  date: string;
  time: string;
  entryDate: Date | null;
  exitDate: Date | null;
  durationMinutes: number | null;
}

interface Area {
  _id: string;
  name: string;
  capacity: number;
}

// --- HELPER FUNCTIONS ---
const processHourlyChartData = (records: ProcessedRecord[]) => {
  const hourlyData: { [key: number]: { entries: number; exits: number } } = {};
  for (let i = 0; i < 24; i++) hourlyData[i] = { entries: 0, exits: 0 };
  records.forEach(record => {
    const dateToUse = record.action === 'ENTRY' ? record.entryDate : record.exitDate;
    if (dateToUse) {
      const hour = dateToUse.getHours();
      if (record.action === 'ENTRY') hourlyData[hour].entries++;
      else hourlyData[hour].exits++;
    }
  });
  return Object.keys(hourlyData).map(hour => ({
    hour: `${hour}:00`,
    Entries: hourlyData[parseInt(hour)].entries,
    Exits: hourlyData[parseInt(hour)].exits,
  }));
};

const processEntriesByPeriod = (records: ProcessedRecord[], period: 'daily' | 'weekly' | 'monthly') => {
  const entries = records.filter(r => r.action === 'ENTRY' && r.entryDate);
  const aggregation: { [key: string]: number } = {};
  entries.forEach(record => {
    const date = new Date(record.entryDate!);
    let key = '';
    if (period === 'daily') {
      key = date.toLocaleDateString('en-CA');
    } else if (period === 'weekly') {
      const dayOfWeek = date.getDay();
      const firstDay = new Date(date.setDate(date.getDate() - dayOfWeek));
      key = `Week of ${firstDay.toLocaleDateString('en-CA')}`;
    } else if (period === 'monthly') {
      key = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
    }
    if (key) aggregation[key] = (aggregation[key] || 0) + 1;
  });
  return Object.keys(aggregation).sort().map(key => ({
    period: key,
    Entries: aggregation[key]
  }));
};

const processOverstayData = (records: ProcessedRecord[], timeLimitMinutes: number) => {
  const overstays = records.filter(r => r.durationMinutes && r.durationMinutes > timeLimitMinutes);
  const aggregation: { [key: string]: number } = {};
  overstays.forEach(record => {
    const date = record.entryDate!;
    const key = date.toLocaleDateString('en-CA');
    aggregation[key] = (aggregation[key] || 0) + 1;
  });
  return Object.keys(aggregation).sort().map(key => ({
    date: key,
    'Overstaying Vehicles': aggregation[key]
  }));
};

// --- MAIN DASHBOARD COMPONENT ---
export default function ParkingDashboard() {
  // --- URL PARAMETER MANAGEMENT ---
  const [searchParams, setSearchParams] = useSearchParams();

  // --- STATE MANAGEMENT ---
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);
  const [areas, setAreas] = useState<Area[]>([]);
  const [selectedAreaId, setSelectedAreaId] = useState<string | null>(null);
  const [allRecords, setAllRecords] = useState<ProcessedRecord[]>([]);
  const [filteredRecords, setFilteredRecords] = useState<ProcessedRecord[]>([]);
  const [existingVehicles, setExistingVehicles] = useState<VehicleRecord[]>([]);
  const [selectedArea, setSelectedArea] = useState<Area | null>(null);
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');
  const [activeFilter, setActiveFilter] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(true);
  const [dashboardLoading, setDashboardLoading] = useState(false);
  const [error, setError] = useState('');
  const [wsConnected, setWsConnected] = useState(false);
  const [lastDataUpdate, setLastDataUpdate] = useState<string | null>(null);
  const [liveUpdatesEnabled, setLiveUpdatesEnabled] = useState(true);

  // State for the new charts
  const [entriesPeriod, setEntriesPeriod] = useState<'daily' | 'weekly' | 'monthly'>('daily');
  const [overstayLimit, setOverstayLimit] = useState(60);
    
  // --- ML Predictor State ---
  const [predictedEntries, setPredictedEntries] = useState<{ period: string, Predictor: number }[]>([]);
  const [predictLoading, setPredictLoading] = useState(false);
  // --- URL PARAMETER FUNCTIONS ---
  const updateURLParams = (updates: Record<string, string | null>) => {
    const newSearchParams = new URLSearchParams(searchParams);
    
    Object.entries(updates).forEach(([key, value]) => {
      if (value === null || value === '') {
        newSearchParams.delete(key);
      } else {
        newSearchParams.set(key, value);
      }
    });
    
    setSearchParams(newSearchParams, { replace: true });
  };


  // --- DATA FETCHING AND PROCESSING ---
  useEffect(() => {
    const verifyAuth = async () => {
      if (!authInterceptor.isAuthenticated()) {
        setIsAuthenticated(false);
        window.location.href = '/login';
      } else setIsAuthenticated(true);
    };
    verifyAuth();
  }, []);

  // Effect to read URL parameters on component mount
  useEffect(() => {
    const areaId = searchParams.get('area');
    const search = searchParams.get('search');
    const start = searchParams.get('startDate');
    const end = searchParams.get('endDate');
    const filter = searchParams.get('filter');

    if (areaId) setSelectedAreaId(areaId);
    if (search) setSearchTerm(search);
    if (start) setStartDate(start);
    if (end) setEndDate(end);
    if (filter) setActiveFilter(filter);
  }, [searchParams]);

  // Effect to manage WebSocket connection and events
  useEffect(() => {
    // Check WebSocket connection status
    const checkConnection = () => {
      const status = webSocketService.getConnectionStatus();
      setWsConnected(status.isConnected);
      setLiveUpdatesEnabled(status.liveUpdatesEnabled);
    };

    // Initial connection check
    checkConnection();

    // Set up WebSocket event listeners
    const cleanupDataUpdated = webSocketService.addEventListener('websocket-data-updated', (data) => {
      console.log('📊 Received data update notification:', data);
      setLastDataUpdate(data.timestamp);
      
      // If the update is for the currently selected area, refresh the data
      if (selectedAreaId && data.areaId === selectedAreaId) {
        console.log('🔄 Refreshing data for current area due to WebSocket update');
        // Trigger a data refresh by re-running the fetch effect
        setDashboardLoading(true);
        // The effect will automatically re-run when selectedAreaId changes
        // We'll add a small delay to ensure the backend has processed the data
        setTimeout(() => {
          setDashboardLoading(false);
        }, 1000);
      }
    });

    const cleanupDataError = webSocketService.addEventListener('websocket-data-error', (data) => {
      console.error('❌ WebSocket data error:', data);
      if (selectedAreaId && data.areaId === selectedAreaId) {
        setError(`Data update failed: ${data.error}`);
      }
    });

    const cleanupRefreshComplete = webSocketService.addEventListener('websocket-refresh-complete', (data) => {
      console.log('🔄 Refresh complete:', data);
      if (selectedAreaId && data.areaId === selectedAreaId) {
        if (data.success) {
          setError(''); // Clear any previous errors
        } else {
          setError(`Manual refresh failed: ${data.error}`);
        }
      }
    });

    const cleanupLiveUpdatesToggled = webSocketService.addEventListener('websocket-live-updates-toggled', (data) => {
      console.log('📊 Live updates toggled:', data.enabled);
      setLiveUpdatesEnabled(data.enabled);
    });

    // Check connection status periodically
    const connectionInterval = setInterval(checkConnection, 5000);

    // Cleanup function
    return () => {
      cleanupDataUpdated();
      cleanupDataError();
      cleanupRefreshComplete();
      cleanupLiveUpdatesToggled();
      clearInterval(connectionInterval);
    };
  }, [selectedAreaId]);

  // Effect to clean up WebSocket room when component unmounts
  useEffect(() => {
    return () => {
      if (selectedAreaId) {
        webSocketService.leaveArea(selectedAreaId);
      }
    };
  }, [selectedAreaId]);

  // Effect to fetch list of parking areas
  useEffect(() => {
    if (isAuthenticated) {
      const fetchAreas = async () => {
        try {
          const response = await getAllParkingAreas();
          if (response.success) setAreas(response.data || []);
        } catch (err) { setError(err instanceof Error ? err.message : 'An unknown error occurred.'); }
        finally { setLoading(false); }
      };
      fetchAreas();
    }
  }, [isAuthenticated]);

  useEffect(() => {
    if (selectedAreaId) {
      // Join WebSocket room for this area
      webSocketService.joinArea(selectedAreaId);
      
      const fetchDashboardData = async () => {
        setDashboardLoading(true);
        setError('');
        try {
          const areaDetails = areas.find(a => a._id === selectedAreaId);
          setSelectedArea(areaDetails || null);
          const [recordsResponse, vehiclesResponse] = await Promise.all([
            getAllRecords(selectedAreaId, 1, 2000),
            getExistingVehicles(selectedAreaId, 1, 1000)
          ]);
          const rawRecords = recordsResponse.records || [];
          const entryMap = new Map<string, any>();
          const processedRecords: ProcessedRecord[] = [];
          rawRecords.filter(r => r.action === 'ENTRY').forEach(rec => {
            entryMap.set(rec.plate, rec);
          });
          rawRecords.forEach(rec => {
            const [month, day, year] = rec.date.split('/');
            const dateObj = new Date(`${year}-${month}-${day}T${rec.time}`);
            if (rec.action === 'EXIT') {
              const matchingEntry = entryMap.get(rec.plate);
              if (matchingEntry) {
                const [entryMonth, entryDay, entryYear] = matchingEntry.date.split('/');
                const entryDateObj = new Date(`${entryYear}-${entryMonth}-${entryDay}T${matchingEntry.time}`);
                const durationMs = dateObj.getTime() - entryDateObj.getTime();
                processedRecords.push({
                  ...rec,
                  entryDate: entryDateObj,
                  exitDate: dateObj,
                  durationMinutes: Math.floor(durationMs / 60000)
                });
                entryMap.delete(rec.plate);
          
          const rawRecords: RawRecord[] = recordsResponse.records || [];
          
          // Process raw records into a more useful format with Date objects and duration
          const entryMap = new Map<string, RawRecord>();
          const processedRecords: ProcessedRecord[] = [];

          // First pass: create a map of the most recent entry for each license plate
          rawRecords.filter((r: RawRecord) => r.action === 'ENTRY').forEach((rec: RawRecord) => {
              entryMap.set(rec.plate, rec);
          });

          // Second pass: process all records, calculating duration for exits
          rawRecords.forEach((rec: RawRecord) => {
              const [month, day, year] = rec.date.split('/');
              const dateObj = new Date(`${year}-${month}-${day}T${rec.time}`);
              
              if (rec.action === 'EXIT') {
                  const matchingEntry = entryMap.get(rec.plate);
                  if (matchingEntry) {
                      const [entryMonth, entryDay, entryYear] = matchingEntry.date.split('/');
                      const entryDateObj = new Date(`${entryYear}-${entryMonth}-${entryDay}T${matchingEntry.time}`);
                      const durationMs = dateObj.getTime() - entryDateObj.getTime();
                      
                      processedRecords.push({
                          ...rec,
                          entryDate: entryDateObj,
                          exitDate: dateObj,
                          durationMinutes: Math.floor(durationMs / 60000)
                      });
                      // Once matched, remove the entry to handle re-entries correctly
                      entryMap.delete(rec.plate);
                  }
              } else { // Entry record
                  processedRecords.push({
                      ...rec,
                      entryDate: dateObj,
                      exitDate: null,
                      durationMinutes: null
                  });
              }
            } else {
              processedRecords.push({
                ...rec,
                entryDate: dateObj,
                exitDate: null,
                durationMinutes: null
              });
            }
          });
          setAllRecords(processedRecords);
          setExistingVehicles(vehiclesResponse.vehicles || []);
        } catch (err) { setError(err instanceof Error ? err.message : 'Failed to load dashboard data.'); }
        finally { setDashboardLoading(false); }
      };
      fetchDashboardData();
    }
  }, [selectedAreaId, areas]);

  useEffect(() => {
    let records = allRecords;
    if (startDate) {
      const start = new Date(startDate);
      start.setHours(0, 0, 0, 0);
      records = records.filter(record => record.entryDate && record.entryDate >= start);
    }
    if (endDate) {
      const end = new Date(endDate);
      end.setHours(23, 59, 59, 999);
      records = records.filter(record => record.entryDate && record.entryDate <= end);
    }
    if (searchTerm) {
      records = records.filter(record =>
        record.plate?.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    setFilteredRecords(records);
  }, [startDate, endDate, searchTerm, allRecords]);

  // --- ML Predictor Effect (MODIFIED) ---
  useEffect(() => {
    if (filteredRecords.length === 0) {
      setPredictedEntries([]);
      return;
    }

    setPredictLoading(true);

    // --- NEW LOGIC: Generate hourly timestamps for the next day ---
    const lastRecordDate = new Date(Math.max(...filteredRecords.map(r => r.entryDate ? r.entryDate.getTime() : 0)));
    const nextDay = new Date(lastRecordDate);
    nextDay.setDate(nextDay.getDate() + 1);
    nextDay.setHours(0, 0, 0, 0); // Start from midnight

    const timestamps: string[] = [];
    for (let i = 0; i < 24; i++) {
        const nextHour = new Date(nextDay);
        nextHour.setHours(i);
        // Format to YYYY-MM-DDTHH:mm:ss as expected by backend
        timestamps.push(nextHour.toISOString().slice(0, 19).replace('T', 'T'));
    }

    getVehicleEntryPredictions(timestamps)
      .then(res => {
        console.log('✅ Raw API Response:', res); // Keep for debugging
        
        const preds = timestamps.map(ts => {
          const date = new Date(ts);
          return {
            period: `${date.getHours()}:00 (${date.toLocaleDateString('en-CA')})`, // e.g., "9:00 (2025-09-07)"
            Predictor: Math.round(res.predictions[ts] ?? 0) // Round the prediction for cleaner display
          };
        });

        console.log('📊 Data being set for the chart:', preds); // Keep for debugging
        setPredictedEntries(preds);
      })
      .catch((err) => {
        console.error("API call failed:", err);
        setPredictedEntries([]);
      })
      .finally(() => setPredictLoading(false));

  }, [filteredRecords]); // Dependency changed, entriesPeriod no longer needed for prediction

  // --- EVENT HANDLERS ---
  const handlePresetFilterClick = (period: string) => {
    setActiveFilter(period);
    const today = new Date();
    const toYYYYMMDD = (date: Date) => date.toISOString().split('T')[0];
    if (period === 'all') {
      setStartDate('');
      setEndDate('');
      updateURLParams({ filter: 'all', startDate: null, endDate: null });
      return;
    }
    
    setEndDate(toYYYYMMDD(today));
    let startDateValue = '';
    
    if (period === 'today') {
      startDateValue = toYYYYMMDD(today);
      setStartDate(startDateValue);
    } else if (period === 'week') {
      const firstDayOfWeek = new Date(today.setDate(today.getDate() - today.getDay()));
      startDateValue = toYYYYMMDD(firstDayOfWeek);
      setStartDate(startDateValue);
    } else if (period === 'month') {
      const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
      startDateValue = toYYYYMMDD(firstDayOfMonth);
      setStartDate(startDateValue);
    }
    
    updateURLParams({ 
      filter: period, 
      startDate: startDateValue, 
      endDate: toYYYYMMDD(today) 
    });
  };

  const handleClearFilters = () => {
    setStartDate('');
    setEndDate('');
    setSearchTerm('');
    setActiveFilter('all');
    updateURLParams({ 
      startDate: null, 
      endDate: null, 
      search: null, 
      filter: 'all' 
    });
  };

  // --- MEMOIZED CHART DATA ---
  const hourlyChartData = useMemo(() => processHourlyChartData(filteredRecords), [filteredRecords]);
  const entriesChartData = useMemo(() => processEntriesByPeriod(filteredRecords, entriesPeriod), [filteredRecords, entriesPeriod]);
  const overstayChartData = useMemo(() => processOverstayData(filteredRecords, overstayLimit), [filteredRecords, overstayLimit]);
  
  // Combine historical and predicted data for the hourly chart
  const combinedHourlyData = useMemo(() => {
    const historical = processHourlyChartData(filteredRecords);
    const predicted = predictedEntries.map(p => {
        const hourMatch = p.period.match(/^(\d+):00/);
        const hourKey = hourMatch ? `${parseInt(hourMatch[1])}:00` : '';
        return { hour: hourKey, Predictor: p.Predictor };
    });

    const combined = historical.map(h => {
        const matchingPred = predicted.find(p => p.hour === h.hour);
        return {
            ...h,
            Predictor: matchingPred ? matchingPred.Predictor : null
        };
    });
    return combined;
  }, [filteredRecords, predictedEntries]);


  // --- RENDER LOGIC ---
  if (loading || isAuthenticated === null) {
    return (
      <div className="relative min-h-screen bg-black text-white flex items-center justify-center">
        <div className="z-10">Loading Dashboard...</div>
      </div>
    );
  }

  return (
    <div className="relative min-h-screen bg-black text-white overflow-hidden">
      {/* Background decorative elements */}
      <div className="absolute top-0 right-0 w-[700px] h-[700px] bg-[#193ED8] rounded-full filter blur-3xl opacity-20" style={{ transform: 'translate(50%, -50%)' }}></div>
      <div className="absolute bottom-0 left-0 w-[700px] h-[700px] bg-[#E8D767] rounded-full filter blur-3xl opacity-20" style={{ transform: 'translate(-50%, 50%)' }}></div>
      <div className="relative z-10 px-4 py-10">
        <div className="max-w-6xl mx-auto space-y-8">
          <header className="text-center">
             <h1 className="text-4xl font-bold tracking-tight">Parking Dashboard</h1>
             <p className="text-sm text-muted mt-2">Live view of parking area activity</p>
             
             {/* WebSocket Connection Status */}
             <div className="flex items-center justify-center gap-4 mt-4">
               <div className={`flex items-center gap-2 px-3 py-1 rounded-full text-sm ${
                 wsConnected 
                   ? (liveUpdatesEnabled 
                       ? 'bg-green-900/30 text-green-400 border border-green-700' 
                       : 'bg-yellow-900/30 text-yellow-400 border border-yellow-700')
                   : 'bg-red-900/30 text-red-400 border border-red-700'
               }`}>
                 <div className={`w-2 h-2 rounded-full ${
                   wsConnected 
                     ? (liveUpdatesEnabled ? 'bg-green-400' : 'bg-yellow-400')
                     : 'bg-red-400'
                 }`}></div>
                 {wsConnected 
                   ? (liveUpdatesEnabled ? 'Live Updates Connected' : 'Live Updates Paused')
                   : 'Live Updates Disconnected'
                 }
               </div>
               
               {selectedAreaId && (
                 <>
                   <Button 
                     variant="outline" 
                     size="sm"
                     onClick={() => {
                       webSocketService.refreshAreaData(selectedAreaId);
                       setDashboardLoading(true);
                       setTimeout(() => setDashboardLoading(false), 2000);
                     }}
                     disabled={!wsConnected || dashboardLoading}
                     className="text-xs"
                   >
                     {dashboardLoading ? 'Refreshing...' : 'Manual Refresh'}
                   </Button>
                   
                   <Button 
                     variant="outline" 
                     size="sm"
                     onClick={() => webSocketService.toggleLiveUpdates()}
                     disabled={!wsConnected}
                     className={`text-xs ${
                       liveUpdatesEnabled 
                         ? 'bg-green-600 hover:bg-green-700 text-white border-green-600' 
                         : 'bg-red-600 hover:bg-red-700 text-white border-red-600'
                     }`}
                   >
                     {liveUpdatesEnabled ? 'Live Updates: ON' : 'Live Updates: OFF'}
                   </Button>
                 </>
               )}
               
               {lastDataUpdate && (
                 <div className="text-xs text-gray-400">
                   Last update: {new Date(lastDataUpdate).toLocaleTimeString()}
                 </div>
               )}
             </div>
          </header>
          {error && <div className="bg-red-900 border border-red-700 rounded-xl p-4 text-red-200">{error}</div>}
          {/* --- CONTROLS SECTION --- */}
          <section className="bg-neutral-800 rounded-xl border border-neutral-700 p-6 shadow-md space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <label htmlFor="area-select" className="block text-lg font-semibold mb-2">Select a Parking Area</label>
                <select id="area-select" value={selectedAreaId || ''} onChange={(e) => {
                  setSelectedAreaId(e.target.value);
                  updateURLParams({ area: e.target.value || null });
                }} className="w-full bg-neutral-700 border-neutral-600 p-2.5 rounded-md text-white focus:ring-2 focus:ring-blue-500">
                    <option value="" disabled>Choose an area...</option>
                    {areas.map((area) => ( <option key={area._id} value={area._id}> {area.name} </option> ))}
                </select>
              </div>
              <div>
                <label htmlFor="search-bar" className="block text-lg font-semibold mb-2">Search by License Plate</label>
                <Input id="search-bar" type="text" placeholder="e.g., ABC-123" value={searchTerm} onChange={(e) => {
                  setSearchTerm(e.target.value);
                  updateURLParams({ search: e.target.value || null });
                }} className="bg-neutral-700 border-neutral-600 text-white" />
              </div>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div className="md:col-span-2 flex flex-col sm:flex-row gap-4">
                <div className="flex-1">
                    <label htmlFor="start-date" className="block text-sm font-medium mb-2">Start Date</label>
                    <Input type="date" id="start-date" value={startDate} onChange={(e) => { 
                      setStartDate(e.target.value); 
                      setActiveFilter('custom');
                      updateURLParams({ startDate: e.target.value || null, filter: 'custom' });
                    }} className="w-full bg-neutral-700 border-neutral-600 rounded-md text-white focus:ring-2 focus:ring-blue-500" />
                </div>
                <div className="flex-1">
                    <label htmlFor="end-date" className="block text-sm font-medium mb-2">End Date</label>
                    <Input type="date" id="end-date" value={endDate} onChange={(e) => { 
                      setEndDate(e.target.value); 
                      setActiveFilter('custom');
                      updateURLParams({ endDate: e.target.value || null, filter: 'custom' });
                    }} className="w-full bg-neutral-700 border-neutral-600 rounded-md text-white focus:ring-2 focus:ring-blue-500" />
                </div>
              </div>
              <div className="flex flex-col space-y-2">
                <label className="block text-sm font-medium mb-2">Quick Filters</label>
                <div className="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-2 gap-2">
                  <Button variant={activeFilter === 'today' ? 'default' : 'outline'} onClick={() => handlePresetFilterClick('today')}>Today</Button>
                  <Button variant={activeFilter === 'week' ? 'default' : 'outline'} onClick={() => handlePresetFilterClick('week')}>Week</Button>
                  <Button variant={activeFilter === 'month' ? 'default' : 'outline'} onClick={() => handlePresetFilterClick('month')}>Month</Button>
                  <Button variant={activeFilter === 'all' ? 'default' : 'outline'} onClick={() => handlePresetFilterClick('all')}>All</Button>
                </div>
              </div>
            </div>
            <div><Button variant="ghost" onClick={handleClearFilters} className="text-sm text-gray-400 hover:text-white">Clear All Filters</Button></div>
          </section>
          {/* --- MAIN DASHBOARD CONTENT --- */}
          {selectedAreaId && (
            dashboardLoading ? (
              <div className="text-center py-10">Loading area data...</div>
            ) : (
              <div className="space-y-8">
                {/* Summary Cards */}
                <section className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <Card className="bg-neutral-800 border-neutral-700">
                    <CardHeader><CardTitle className="text-blue-400">Current Occupancy</CardTitle></CardHeader>
                    <CardContent className="text-3xl font-bold">{existingVehicles.length} / {selectedArea?.capacity || 'N/A'}</CardContent>
                  </Card>
                  <Card className="bg-neutral-800 border-neutral-700">
                    <CardHeader><CardTitle className="text-green-400">Total Entries (Filtered)</CardTitle></CardHeader>
                    <CardContent className="text-3xl font-bold">{filteredRecords.filter(r => r.action === 'ENTRY').length}</CardContent>
                  </Card>
                  <Card className="bg-neutral-800 border-neutral-700">
                    <CardHeader><CardTitle className="text-yellow-400">Total Exits (Filtered)</CardTitle></CardHeader>
                    <CardContent className="text-3xl font-bold">{filteredRecords.filter(r => r.action === 'EXIT').length}</CardContent>
                  </Card>
                </section>
                {/* --- MODIFIED CHART LAYOUT --- */}
                <section className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                  {/* Chart 1: Hourly Activity with Prediction */}
                  <div className="bg-neutral-800 rounded-xl border border-neutral-700 p-6 shadow-md lg:col-span-2">
                    <h3 className="text-lg font-semibold mb-4">Hourly Activity (Historical & Predicted)</h3>
                    <ResponsiveContainer width="100%" height={300}>
                      <BarChart data={combinedHourlyData}>
                        <XAxis dataKey="hour" stroke="#888888" fontSize={12} />
                        <YAxis stroke="#888888" fontSize={12} />
                        <Tooltip wrapperClassName="!bg-neutral-900 !border-neutral-700" />
                        <Legend />
                        <Bar dataKey="Entries" fill="#3b82f6" radius={[4, 4, 0, 0]} />
                        <Bar dataKey="Exits" fill="#f59e0b" radius={[4, 4, 0, 0]} />
                         <Line type="monotone" dataKey="Predictor" stroke="#22c55e" strokeWidth={2} dot={{ r: 4 }} />
                      </BarChart>
                    </ResponsiveContainer>
                  </div>
                  {/* Chart 2: Historical Vehicle Entries */}
                  <div className="bg-neutral-800 rounded-xl border border-neutral-700 p-6 shadow-md">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="text-lg font-semibold">Historical Vehicle Entries</h3>
                      <div className="flex items-center gap-2">
                        <Button size="sm" variant={entriesPeriod === 'daily' ? 'default' : 'outline'} onClick={() => setEntriesPeriod('daily')}>Daily</Button>
                        <Button size="sm" variant={entriesPeriod === 'weekly' ? 'default' : 'outline'} onClick={() => setEntriesPeriod('weekly')}>Weekly</Button>
                        <Button size="sm" variant={entriesPeriod === 'monthly' ? 'default' : 'outline'} onClick={() => setEntriesPeriod('monthly')}>Monthly</Button>
                      </div>
                    </div>
                    <ResponsiveContainer width="100%" height={300}>
                      <LineChart data={entriesChartData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                        <XAxis dataKey="period" stroke="#888888" fontSize={12} />
                        <YAxis stroke="#888888" fontSize={12} />
                        <Tooltip wrapperClassName="!bg-neutral-900 !border-neutral-700" />
                        <Legend />
                        <Line type="monotone" dataKey="Entries" stroke="#22c55e" strokeWidth={2} dot={false} />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                  {/* Chart 3: Vehicles Overstay Analysis */}
                  <div className="bg-neutral-800 rounded-xl border border-neutral-700 p-6 shadow-md">
                    <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
                      <h3 className="text-lg font-semibold">Vehicles Overstay Analysis</h3>
                      <div className="flex items-center gap-2">
                        <label htmlFor="overstay-limit" className="text-sm">Time Limit (mins):</label>
                        <Input id="overstay-limit" type="number" value={overstayLimit} onChange={(e) => setOverstayLimit(parseInt(e.target.value) || 0)} className="bg-neutral-700 border-neutral-600 w-24" />
                      </div>
                    </div>
                    <ResponsiveContainer width="100%" height={300}>
                      <BarChart data={overstayChartData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                        <XAxis dataKey="date" stroke="#888888" fontSize={12} />
                        <YAxis stroke="#888888" fontSize={12} allowDecimals={false} />
                        <Tooltip wrapperClassName="!bg-neutral-900 !border-neutral-700" />
                        <Legend />
                        <Bar dataKey="Overstaying Vehicles" fill="#ef4444" radius={[4, 4, 0, 0]} />
                      </BarChart>
                    </ResponsiveContainer>
                  </div>
                </section>
                {/* Records Table */}
                <section className="bg-neutral-800 rounded-xl border border-neutral-700 p-6 shadow-md">
                  <h3 className="text-lg font-semibold mb-4">Filtered Records ({filteredRecords.length} found)</h3>
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>License Plate</TableHead>
                        <TableHead>Action</TableHead>
                        <TableHead>Date & Time</TableHead>
                        <TableHead>Duration (mins)</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredRecords.length > 0 ? (
                        filteredRecords.slice(0, 10).map((record) => (
                          <TableRow key={record._id}>
                            <TableCell>{record.plate || 'N/A'}</TableCell>
                            <TableCell>{record.action}</TableCell>
                            <TableCell>{record.date} {record.time}</TableCell>
                            <TableCell>{record.durationMinutes !== null ? record.durationMinutes : 'N/A'}</TableCell>
                          </TableRow>
                        ))
                      ) : (
                        <TableRow>
                          <TableCell colSpan={4} className="text-center">No records found matching your filters.</TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </section>
              </div>
            )
          )}
        </div>
      </div>
    </div>
  );
}